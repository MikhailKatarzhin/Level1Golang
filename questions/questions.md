1.	Какой самый эффективный способ конкатенации строк?
- strings.Builder

2.	Что такое интерфейсы, как они применяются в Go?
- Программный механизм в Go, позволяющий определять набор методов, который может быть реализован разными типами, обеспечивая гибкость и полиморфизм в коде

3.	Чем отличаются RWMutex от Mutex?
- RWMutex позволяет множеству читателей одновременно читать данные, обеспечивая исключительный доступ на запись

4.	Чем отличаются буферизированные и не буферизированные каналы?

#### Не буферизованные
- передают данные напрямую от отправителя к получателю без хранения их внутри канала
- отправитель будет заблокирован, пока данные не будут получены из канала принимающей стороной, и наоборот
- обеспечивают точную синхронизацию между горутинами

#### Буферизованные
 
- имеют фиксированный размер и позволяют отправителю посылать данные до заполнения буфера
- не блокируют отправителя, пока буфер не заполнен
- принимающая сторона блокируется только в случае пустого буфера и ожидает данных

5.	Какой размер у структуры struct{}{}?
- 0 б

6.	Есть ли в Go перегрузка методов или операторов?
- Нет

7.	В какой последовательности будут выведены элементы map[int]int?
```
Пример:
m[0]=1
m[1]=124
m[2]=281
```
- случайной

8.	В чем разница make и new?
- make инициализирует внутреннюю структуру данных
- new используется для выделения памяти для указателей на типы данных и возвращает указатель на нулевое значение указанного типа данных


9.	Сколько существует способов задать переменную типа slice или map?

### Slice
- Инициализация пустого слайса
- Создание слайса с начальной ёмкостью
- Инициализация слайса с элементами

### Map
- Инициализация пустой map
- Инициализация map с элементами

10.	Что выведет данная программа и почему?
```
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
Выведет 1 дважды, так как при вызове функции update значение указателя p изменяется локально


11.	Что выведет данная программа и почему?
```
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
Программа выведет числа от 0 до 4 в случайном порядке, за которыми последует сообщение "exit"
ПОрядок случаен по причине конкурентного вывода

12.	Что выведет данная программа и почему?
```
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
выведет 0, так как внутри условия объявляется новая n локально, за пределами блока if её не сущестует

13.	Что выведет данная программа и почему?
```
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
Выведет [100 2 3 4 5] :
При передаче среза a в функцию someAction, передается копия ссылки на массив.
Когда вы изменяете элемент среза внутри функции, это изменение отразится на оригинальном массиве

14.	Что выведет данная программа и почему?
```
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
выведет ["b" "b" "a"] - ["a" "a"]
изменения происходят с локальной копией среза slice, которая создается при передаче аргумента в анонимную функцию